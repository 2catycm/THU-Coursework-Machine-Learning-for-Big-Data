# AUTOGENERATED! DO NOT EDIT! File to edit: ../../notebooks/theory_assignments/A6/P_Assignment6_yecanming.ipynb.

# %% auto 0
__all__ = ['plot_binary_classification_3d', 'calculate_gini_index_for_subset', 'calculate_gini_index']

# %% ../../notebooks/theory_assignments/A6/P_Assignment6_yecanming.ipynb 12
# 创建图表，
# 需要有网格线，
# 需要有文本标注点的名字和坐标
# 坐标轴名称和正负例的图例要和李航书的一样
# 正负例的形状不同（黑白打印的审稿人），颜色不同
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def plot_binary_classification_3d(X, y, labels=[1, -1], label_names=['正例', '负例'],
                                  label_colors=['blue', 'red'],
                                  label_markers=['o', 'x'], 
                                  x_names=['x(1)', 'x(2)', 'x(3)'], 
                                  point_size=100,
                                  text_offset=(0.1, 0.1, 0.1), 
                                  point_names=None, 
                                  title='数据点可视化', 
                                  size=(9, 6), 
                                  ):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')

    if point_names is None:
        point_names = [f'x{i+1}' for i in range(len(X))]

    # 绘制正例和负例，并标注点名和坐标
    label_has_drawn = set()
    for i, (x, label) in enumerate(zip(X, y)):
        
        label_idx = labels.index(label)
        if label_idx in label_has_drawn:
            label_name = ''
        else:
            label_has_drawn.add(label_idx)
            label_name = label_names[label_idx]
        
        ax.scatter(x[0], x[1], x[2], color=label_colors[label_idx], marker=label_markers[label_idx], 
                   label=label_name, 
                   s=point_size)
        ax.text(x[0] + text_offset[0], x[1] + text_offset[1], x[2] + text_offset[2], f' {point_names[i]} ({x[0]}, {x[1]}, {x[2]})', fontsize=12, ha='left')

    # 添加网格线
    ax.grid(True)

    # 添加图例
    ax.legend()

    # 修改坐标轴名称
    ax.set_xlabel(x_names[0])
    ax.set_ylabel(x_names[1])
    ax.set_zlabel(x_names[2])
    ax.set_title(title)
    fig.set_size_inches(*size)
    
    ax.set_box_aspect((1,1,1))
    
    return fig, ax

# %% ../../notebooks/theory_assignments/A6/P_Assignment6_yecanming.ipynb 18
def calculate_gini_index_for_subset(df_subset):
    """
    计算给定 DataFrame 子集的 Gini 指数。
    
    参数:
    df_subset (pd.DataFrame): 包含类别标签的 DataFrame 子集。
    
    返回:
    float: Gini 指数。
    """
    # 获取类别标签的频率
    class_counts = df_subset.iloc[:, -1].value_counts()
    total_instances = len(df_subset)
    
    # 计算 Gini 指数
    gini_index = 1.0 - sum((count / total_instances) ** 2 for count in class_counts)
    
    return gini_index

def calculate_gini_index(df, feature, value):
    # 提取特征等于特定值的数据子集
    equal_set = df[df[feature] == value]
    ne_set = df[df[feature] != value]
    
    equal_ratio = len(equal_set) / len(df)
    ne_ratio = len(ne_set) / len(df)
    
    equal_set_gini_index = calculate_gini_index_for_subset(equal_set)
    ne_set_gini_index = calculate_gini_index_for_subset(ne_set)
    
    return (equal_ratio * equal_set_gini_index) + (ne_ratio * ne_set_gini_index)
    
    
