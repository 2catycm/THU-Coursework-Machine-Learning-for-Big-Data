# AUTOGENERATED! DO NOT EDIT! File to edit: ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb.

# %% auto 0
__all__ = ['df', 'df_category_info', 'font', 'data_column', 'res', 'interesting_col', 'grouped_data', 'normality_results',
           'std_devs', 'ratio_largest_to_smallest', 'variance_homogeneity', 'group_values_list', 'bartlett_result',
           'model', 'anova_table', 'group_values_df', 'continuous_vars', 'chosen_cols', 'anova_oneway', 'draw_hist',
           'test_normality_group', 'homogeneity_of_variance', 'auto_anova_for_df', 'draw_box', 'auto_friedman_for_df',
           'auto_kruskal_for_df']

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 10
import pandas as pd
df = pd.read_excel("data.xlsx", sheet_name="data")
df.head()

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 11
df_category_info = pd.read_excel("data.xlsx", sheet_name="category_info")
df_category_info.head()

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 13
df.columns, df.columns[7-1] 

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 15
# 设置matplotlib支持中文显示
# 参考网上资料，说要设为 SimHei
# plt.rcParams['font.sans-serif'] = ['SimHei']  # 指定默认字体  
plt.rcParams['axes.unicode_minus'] = False  # 解决保存图像是负号'-'显示为方块的问题
# 但是SimHei这个linux上不存在，好像是微软的字体，不开源。
# 参考另一篇博客解决这个问题 https://blog.csdn.net/MAO_TOU/article/details/93998905
from matplotlib import font_manager
font = font_manager.FontProperties(fname="/usr/share/fonts/opentype/noto/NotoSansCJK-Regular.ttc")
plt.rcParams['font.sans-serif'] = [font.get_name()]

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 16
from matplotlib import pyplot as plt
plt.figure(figsize=(10, 6))
import seaborn as sns
# plt.hist(df['平均年龄'], bins=10, color='skyblue', edgecolor='black')  # 使用列名绘制直方图
sns.displot(data=df, x=df.columns[7-1] , kde=True, kind="hist")
plt.title('平均年龄的经验概率密度图')
plt.xlabel('平均年龄')
plt.ylabel('频数')
plt.grid(axis='y', alpha=0.75)
plt.show()

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 21
# 提取第七列数据
# data_column = df.iloc[:, 7-1]
data_column = df[df.columns[7-1]]
data_column

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 23
from scipy import stats
# 进行Kolmogorov-Smirnov检验
# ks_stat, ks_pvalue = stats.kstest(data_column, 'norm')
# 另一种写法
res = stats.ks_1samp(data_column, stats.norm.cdf, alternative='two-sided')
if res.pvalue < 0.05:
    print('Reject null hypothesis! Data is not normally distributed.')
res

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 25
stats.anderson(data_column, dist='norm')

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 28
# 进行D'Agostino-Pearson检验
res = stats.normaltest(data_column)
if res.pvalue < 0.05:
    print('Reject null hypothesis! Data is not normally distributed.')
res

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 34
sns.displot(data=df, x=df.columns[7-1], hue="群类别", kde=True, kind="hist")
plt.ylabel("频数")

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 37
interesting_col = df.columns[7-1]
grouped_data = df.groupby('群类别')
# grouped_data
normality_results = {}
for name, group in grouped_data:
    normality_result = {}
    data_column = group[interesting_col]
    res = stats.ks_1samp(data_column, stats.norm.cdf, alternative='two-sided')
    normality_result['Kolmogorov-Smirnov'] = "Not Normal" if res.pvalue < 0.05 else "Normal"
    res = stats.anderson(data_column, dist='norm')
    critical_value = res.critical_values[2] # 0.05 level
    normality_result['Anderson-Darling'] = "Not Normal" if res.statistic > critical_value else "Normal"
    res = stats.normaltest(data_column)
    normality_result["D'Agostino-Pearson"] = "Not Normal" if res.pvalue < 0.05 else "Normal"
    normality_results[name] = normality_result
pd.DataFrame(normality_results)

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 40
std_devs = grouped_data[interesting_col].std()
ratio_largest_to_smallest = std_devs.max() / std_devs.min() 
variance_homogeneity = ratio_largest_to_smallest<= 2
std_devs, ratio_largest_to_smallest, variance_homogeneity

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 42
group_values_list = [grouped_data[interesting_col].get_group(x).values for x in grouped_data.groups]
group_values_list[0][:5]

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 43
from scipy import stats
# 进行Bartlett的方差齐性检验
bartlett_result = stats.bartlett(*group_values_list)
if bartlett_result.pvalue < 0.05:
    print("Reject the null hypothesis of equal variances! ")
bartlett_result

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 47
# 绘制分组分布图
plt.figure(figsize=(10, 6))
sns.boxplot(x='群类别', y=df.columns[7-1], data=df)
plt.title('群类别与平均年龄的分布图')
plt.xlabel('群类别')
plt.ylabel('平均年龄')
plt.show()

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 49
from scipy.stats import f_oneway # ANOVA 又称 F检验，所以scipy命名为f_oneway
res = f_oneway(*group_values_list)
if res.pvalue < 0.05:
    print("Reject null hypothesis! There is a significant difference in the means between the groups.")
res

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 51
import statsmodels.api as sm
from statsmodels.formula.api import ols
model = ols(f'{df.columns[1]} ~ C({df.columns[7-1]})', data=df).fit()

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 52
model.f_pvalue

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 54
anova_table = sm.stats.anova_lm(model, test='F', typ=2)
anova_table

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 57
import numpy as np
import pandas as pd
def anova_oneway(
    *groups: np.ndarray # 不同i的samples[i]表示不同的treatment下的实验数据。这里有个关键的地方，就是每一个group不要求有相同的长度，所以不是二维数据，而是一列不定长的np.array。
                 )->pd.DataFrame: # 返回ANOVA表格。包括我们课堂上学习的内容。
    if len(groups) < 2:
            raise TypeError('我们需要至少两个组才能进行ANOVA分析, 而'
                            f' 你给了我 {len(groups)} 个组.')
    means = [sum(group)/len(group) for group in groups]
    lengths_of_each_group = [len(group) for group in groups]
    
    # grand_mean = sum(means) / len(means) # 错误的公式
    # 正确公式1
    grand_mean = sum([mean*length for mean, length in zip(means, lengths_of_each_group)]) / sum(lengths_of_each_group)
    # 正确公式2
    flattened_samples = np.concatenate(groups)
    grand_mean_2 = flattened_samples.mean()
    assert np.isclose(grand_mean, grand_mean_2)

    # 平方和（Sum of Squares, SS）这个缩写课上其实没有讲，所以没听懂。
    # 计算组间平方和（Between SS）
    # between_ss = len(samples) * sum(mean**2 for mean in means)  # 错误的公式, 按照字面意义理解了 SS
    # 想算每一个group，如果把 grand mean 当做平均值， 把这个group的均值当做这个group所有人的值，那么这个group会有多大方差（没平均）。
    between_ss = sum([length * (mean - grand_mean)**2 for mean, length in zip(means, lengths_of_each_group)])
    
    # 计算组内平方和（Within SS）
    within_ss = sum(
        [
            (sum([(value-means[group_index])**2 for value in group]) # 每一个组自己求和
    ) for group_index, group in enumerate(groups) # 外层求和
        ]
    )

    # 计算总平方和（Total SS）
    # 但是我们实际上并不是算平方和啊，我们算的是和平均值差的平方和啊？这个取名。。。
    # ss_total = sum(sum(x**2 for x in sample) for sample in samples) # 错误的公式, 按照字面意义理解了 SS。
    # 正确公式1
    ss_total = sum(sum((x-grand_mean)**2 for x in group) for group in groups)
    
    # 正确公式2
    ss_total2 = between_ss + within_ss
    assert np.isclose(ss_total, ss_total2), f"{ss_total} vs {ss_total2}"
    
    # 课堂上其实没有讲，这里有一个重要的定理叫做 方差分解定理（law of total variance），
    # Var(X)=E[Var(X∣Y) ]+Var(E[X∣Y])
    

    
    # 计算自由度（df）
    df_between = len(groups) - 1
    df_within = sum([len(group) - 1 for group in groups]) # 注意这里是每一个 treatment 的自由度的和。
    
    # 计算均方（MS）
    ms_between = between_ss / df_between
    ms_within = within_ss / df_within
    
    # 计算F值
    f_value = ms_between / ms_within
    
    # 计算p值
    p_value_bigger_than_f = 1 - stats.f.cdf(f_value, dfn=df_between, dfd=df_within)
    p_value_excel = stats.f.pdf(f_value, dfn=df_between, dfd=df_within)
    # p_value = 1 - stats.f.cdf(f_value, dfn=df_within, dfd=df_between)
    
    # 创建ANOVA表格
    anova_table = {
        'Source': ['Between', 'Within', 'Total'],
        'Sum of Squares (SS)': [between_ss, within_ss, ss_total], # 拒绝缩写！我们要清晰地告诉用户这个是什么意思。
        'Degrees of Freedom (df)': [df_between, df_within, df_between + df_within], # 拒绝缩写
        'Mean Square (MS)': [ms_between, ms_within, None], # 拒绝缩写
        'F': [f_value, None, None],
        'p': [p_value_bigger_than_f, None, None],
        'p_excel': [p_value_excel, None, None]
    }
    return pd.DataFrame(anova_table)
res = anova_oneway(*group_values_list)
res

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 60
group_values_df = pd.DataFrame(group_values_list)
group_values_df.to_excel("group_values.xlsx")
group_values_df

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 63
continuous_vars = df.select_dtypes(include=['float'])
continuous_vars.describe()

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 65
import random
# random.seed(5)
random.seed(0)
chosen_cols = random.choices(continuous_vars.columns, k=3)
chosen_cols

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 67
import seaborn as sns
def draw_hist(df, chosen_cols, hue_col='群类别', transform = None, column_name_transform = None):
    if transform is None: transform = lambda x: x
    if column_name_transform is None: column_name_transform = lambda x: x
    fig, axs = plt.subplots(1, len(chosen_cols), figsize=(15, 5))  #
    for i, col in enumerate(chosen_cols):
        df[f"{col}_transformed_tmp"] = transform(df[col].to_numpy())
        # plt.hist(df['平均年龄'], bins=10, color='skyblue', edgecolor='black')  # 使用列名绘制直方图
        sns.histplot(data=df, x=f"{col}_transformed_tmp" , kde=True, ax=axs[i])
        axs[i].set_ylabel('频数')
        axs[i].set_xlabel(column_name_transform(col))
        
        # axs[i].grid(axis='y', alpha=0.75)
    fig, axs = plt.subplots(1, len(chosen_cols), figsize=(15, 5))  #
    for i, col in enumerate(chosen_cols):
        # plt.hist(df['平均年龄'], bins=10, color='skyblue', edgecolor='black')  # 使用列名绘制直方图
        sns.histplot(data=df, x=f"{col}_transformed_tmp" , kde=True, hue=hue_col, ax=axs[i])
        axs[i].set_ylabel('频数')
        axs[i].set_xlabel(column_name_transform(col))
        # 删除 f"{col}_transformed_tmp" 列
        del df[f"{col}_transformed_tmp"]

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 70
import numpy as np
def test_normality_group(df, interesting_col, hue_col='群类别', transform = None):
    if transform is None:
        transform = lambda x: x
    grouped_data = df.groupby(hue_col)
    # grouped_data
    normality_results = {}
    for name, group in grouped_data:
        normality_result = {}
        data_column = group[interesting_col].to_numpy()
        data_column = transform(data_column)
        res = stats.ks_1samp(data_column, stats.norm.cdf, alternative='two-sided')
        normality_result['Kolmogorov-Smirnov'] = "Not Normal" if res.pvalue < 0.05 else "Normal"
        res = stats.anderson(data_column, dist='norm')
        critical_value = res.critical_values[2] # 0.05 level
        normality_result['Anderson-Darling'] = "Not Normal" if res.statistic > critical_value else "Normal"
        res = stats.normaltest(data_column)
        normality_result["D'Agostino-Pearson"] = "Not Normal" if res.pvalue < 0.05 else "Normal"
        normality_results[name] = normality_result
    return pd.DataFrame(normality_results)

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 77
from scipy import stats
def homogeneity_of_variance(df, interesting_col, hue_col="群类别", transform=None):
    if transform is None:
        transform = lambda x: x
    new_col_name = f"{interesting_col}_transformed_tmp"
    df[new_col_name] = transform(df[interesting_col].to_numpy())
    interesting_col = new_col_name
    
    grouped_data = df.groupby(hue_col)

    std_devs = grouped_data[interesting_col].std()
    ratio_largest_to_smallest = std_devs.max() / std_devs.min() 
    variance_homogeneity = ratio_largest_to_smallest<= 2
    if not variance_homogeneity:
        print("The variances are not homogeneous!")
    else:
        print("The variances may be homogeneous, according to rule of thumb.")
    
    group_values_list = [grouped_data[interesting_col].get_group(x).values for x in grouped_data.groups]
    bartlett_result = stats.bartlett(*group_values_list)
    if bartlett_result.pvalue < 0.05:
        print("Reject the null hypothesis of equal variances! ")
        
    del df[new_col_name]

    return dict(
        ratio_largest_to_smallest=ratio_largest_to_smallest,
        bartlett_result=bartlett_result
    )

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 84
def auto_anova_for_df(df, interesting_col, hue_col="群类别", transform=None):
    if transform is None:
        transform = lambda x: x
    new_col_name = f"{interesting_col}_transformed_tmp"
    df[new_col_name] = transform(df[interesting_col].to_numpy())
    interesting_col = new_col_name
    grouped_data = df.groupby(hue_col)
    group_values_list = [grouped_data[interesting_col].get_group(x).values for x in grouped_data.groups]
    res = anova_oneway(*group_values_list)
    del df[new_col_name]
    return res

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 89
def draw_box(df, chosen_cols, hue_col='群类别', transform = None, column_name_transform = None):
    if transform is None: transform = lambda x: x
    if column_name_transform is None: column_name_transform = lambda x: x
    fig, axs = plt.subplots(1, len(chosen_cols), figsize=(15, 5))  #
    for i, col in enumerate(chosen_cols):
        df[f"{col}_transformed_tmp"] = transform(df[col].to_numpy())
        sns.boxplot(x=hue_col, y=f"{col}_transformed_tmp", data=df, ax=axs[i])
        axs[i].set_ylabel(column_name_transform(col))
        del df[f"{col}_transformed_tmp"]

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 92
from scipy import stats
def auto_friedman_for_df(df, interesting_col, hue_col="群类别", transform=None):
    if transform is None:
        transform = lambda x: x
    new_col_name = f"{interesting_col}_transformed_tmp"
    df[new_col_name] = transform(df[interesting_col].to_numpy())
    interesting_col = new_col_name
    grouped_data = df.groupby(hue_col)
    group_values_list = [grouped_data[interesting_col].get_group(x).values for x in grouped_data.groups]
    
    res = stats.friedmanchisquare(*group_values_list)
    
    del df[new_col_name]
    return res

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 95
from scipy import stats
def auto_kruskal_for_df(df, interesting_col, hue_col="群类别", transform=None):
    if transform is None:
        transform = lambda x: x
    new_col_name = f"{interesting_col}_transformed_tmp"
    df[new_col_name] = transform(df[interesting_col].to_numpy())
    interesting_col = new_col_name
    grouped_data = df.groupby(hue_col)
    group_values_list = [grouped_data[interesting_col].get_group(x).values for x in grouped_data.groups]
    
    res = stats.kruskal(*group_values_list)
    
    del df[new_col_name]
    return res
